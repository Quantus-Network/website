---
import type { ImageMetadata } from "astro";
import { Image } from "astro:assets";

// Carousel.astro
export interface CarouselItem {
  id: string;
  alt: string;
  href: string;
  src: ImageMetadata;
}

export interface Props {
  items: CarouselItem[];
  autoplay?: boolean;
  autoplayInterval?: number;
  showDots?: boolean;
  loop?: boolean;
  className?: string;
  slideClassName?: string;
  renderCustomContent?: boolean;
}

const {
  items = [],
  autoplay = false,
  autoplayInterval = 3000,
  showDots = true,
  loop = true,
  className = "",
  slideClassName = "",
  renderCustomContent = false,
} = Astro.props;

const carouselId = `carousel-${Math.random().toString(36).substring(2, 9)}`;

// Create duplicated items for infinite loop
const duplicatedItems =
  loop && items.length > 1 ? [...items, ...items, ...items] : items;
---

<div class={`relative w-full ${className}`} data-carousel-id={carouselId}>
  <div class="relative flex w-full items-center">
    <div class="w-full overflow-hidden rounded-lg">
      <div class="carousel-track ms-[calc(-132px+50vw)] flex gap-5" data-track>
        {
          duplicatedItems.map((item, index) => (
            <div
              class={`min-h-[200px] w-fit flex-none ${slideClassName}`}
              data-slide-index={index}
              data-item-id={item.id}
              data-original-index={
                loop && items.length > 1 ? index % items.length : index
              }
            >
              <div class="flex h-full w-full items-center justify-center">
                <slot name="slide">
                  <div class="rounded-quantus flex h-full w-full items-center justify-center overflow-hidden text-center">
                    <a
                      class="inline-block h-[394px] w-[264px]"
                      href={item.href}
                      target="_blank"
                      rel="noopener noreferrer"
                      draggable="false"
                    >
                      <Image
                        class="w-full"
                        src={item.src}
                        alt={item.alt}
                        widths={[264, 281]}
                        sizes={"(min-width: 281px) 100vw, 264px"}
                        layout="full-width"
                        draggable="false"
                      />
                    </a>
                  </div>
                </slot>
              </div>
            </div>
          ))
        }
      </div>
    </div>
  </div>

  {
    showDots && items.length > 1 && (
      <div class="mt-8 flex justify-center gap-2">
        {items.map((_, index) => (
          <button
            class="border-carousel-dot-border hover:bg-quantus-dark-blue [&.active]:bg-carousel-dot size-4 cursor-pointer rounded-full border transition-colors duration-200 [&.active]:w-10 [&.active]:rounded-[23px] [&.active]:border-none"
            data-slide={index}
            aria-label={`Go to slide ${index + 1}`}
          />
        ))}
      </div>
    )
  }
</div>

<style>
  .carousel-track {
    transition: transform 0.3s ease-in-out;
    will-change: transform;
    touch-action: pan-y pinch-zoom;
  }

  .carousel-track.no-transition {
    transition: none;
  }

  .carousel-track.swiping {
    transition: none;
  }
</style>

<script
  define:vars={{
    carouselId,
    autoplay,
    autoplayInterval,
    loop,
    renderCustomContent,
    itemsLength: items.length,
  }}
>
  class Carousel {
    constructor(container, options = {}) {
      this.container = container;
      this.track = container.querySelector("[data-track]");
      this.slides = Array.from(
        container.querySelectorAll("[data-slide-index]"),
      );
      this.dots = Array.from(container.querySelectorAll("[data-slide]"));

      this.itemsLength = options.itemsLength || this.slides.length;
      this.currentIndex =
        options.loop && this.itemsLength > 1 ? this.itemsLength : 0;
      this.visualIndex = 0;
      this.autoplay = options.autoplay || false;
      this.autoplayInterval = options.autoplayInterval || 3000;
      this.loop = options.loop !== undefined ? options.loop : true;
      this.autoplayTimer = null;
      this.renderCustomContent = options.renderCustomContent || false;
      this.slideWidth = 264;
      this.slideGap = 20;
      this.isTransitioning = false;

      // Touch/swipe properties
      this.isDragging = false;
      this.startX = 0;
      this.startY = 0;
      this.currentX = 0;
      this.currentY = 0;
      this.dragOffset = 0;
      this.initialTransform = 0;
      this.velocityTracker = [];
      this.lastTime = 0;
      this.isVerticalScroll = false;
      this.hasMoved = false; // This flag is key!
      this.dragStartTime = 0;

      // Debounce timers
      this.navigationDebounce = null;
      this.autoplayResumeTimeout = null;

      this.init();
    }

    init() {
      if (this.slides.length === 0) return;

      if (this.renderCustomContent) {
        this.renderSlideContent();
      }

      this.updateSlidePosition(false);
      this.updateDots();
      this.bindEvents();

      if (this.autoplay) {
        this.startAutoplay();
      }
    }

    bindEvents() {
      this.dots.forEach((dot, index) => {
        dot.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.debouncedGoToSlide(index);
        });
      });

      this.container.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft") {
          e.preventDefault();
          this.debouncedGoToPrevious();
        }
        if (e.key === "ArrowRight") {
          e.preventDefault();
          this.debouncedGoToNext();
        }
      });

      if (this.autoplay) {
        this.container.addEventListener("mouseenter", () =>
          this.stopAutoplay(),
        );
        this.container.addEventListener("mouseleave", () =>
          this.startAutoplay(),
        );
      }

      this.track.addEventListener("transitionend", () => {
        this.handleTransitionEnd();
      });

      this.bindTouchEvents();
      this.bindMouseEvents();
    }

    debouncedGoToSlide(index) {
      if (this.navigationDebounce) return;

      this.navigationDebounce = setTimeout(() => {
        this.goToSlide(index);
        this.navigationDebounce = null;
      }, 50);
    }

    debouncedGoToNext() {
      if (this.navigationDebounce) return;

      this.navigationDebounce = setTimeout(() => {
        this.goToNext();
        this.navigationDebounce = null;
      }, 50);
    }

    debouncedGoToPrevious() {
      if (this.navigationDebounce) return;

      this.navigationDebounce = setTimeout(() => {
        this.goToPrevious();
        this.navigationDebounce = null;
      }, 50);
    }

    bindTouchEvents() {
      this.container.addEventListener(
        "touchstart",
        (e) => {
          // MODIFIED: Only prevent drag on interactive elements that are NOT links inside the track
          if (e.target.closest("button")) return;
          this.handleStart(e.touches[0].clientX, e.touches[0].clientY);
        },
        { passive: true }, // Changed to passive for better scroll performance
      );

      this.container.addEventListener(
        "touchmove",
        (e) => {
          if (!this.isDragging) return;
          // We will prevent default inside handleMove if needed
          this.handleMove(e.touches[0].clientX, e.touches[0].clientY, e);
        },
        { passive: false },
      );

      this.container.addEventListener("touchend", (e) => {
        this.handleEnd(
          e.changedTouches[0].clientX,
          e.changedTouches[0].clientY,
        );
      });

      this.container.addEventListener("touchcancel", () => {
        this.handleCancel();
      });
    }

    bindMouseEvents() {
      this.container.addEventListener("mousedown", (e) => {
        // MODIFIED: Only prevent drag on interactive elements that are NOT links inside the track
        if (e.target.closest("button")) return;

        // Check if the target is a link or has a link as an ancestor within a slide
        if (e.target.closest("[data-slide-index] a")) {
          // We allow the drag to start, but will prevent the click later if needed.
        }

        this.handleStart(e.clientX, e.clientY);
        // Don't prevent default here to allow other interactions, will be handled in move.
      });

      document.addEventListener("mousemove", (e) => {
        this.handleMove(e.clientX, e.clientY, e);
      });

      document.addEventListener("mouseup", (e) => {
        this.handleEnd(e.clientX, e.clientY);
      });

      this.container.addEventListener("contextmenu", (e) => {
        if (this.hasMoved) {
          e.preventDefault();
        }
      });

      // This is the key part for preventing the click after a drag.
      this.container.addEventListener(
        "click",
        (e) => {
          if (this.hasMoved) {
            e.preventDefault();
            e.stopPropagation();
          }
        },
        true, // Use capture phase to intercept the click before it reaches the link.
      );
    }

    handleStart(x, y) {
      if (this.navigationDebounce) {
        clearTimeout(this.navigationDebounce);
        this.navigationDebounce = null;
      }
      if (this.isTransitioning) return;

      this.isDragging = true;
      this.hasMoved = false; // Reset hasMoved on every new interaction
      this.isVerticalScroll = false;

      this.startX = x;
      this.startY = y;
      this.currentX = x;
      this.currentY = y;

      this.dragOffset = 0;
      this.initialTransform =
        -this.currentIndex * (this.slideWidth + this.slideGap);

      this.velocityTracker = [];
      this.dragStartTime = Date.now();
      this.lastTime = this.dragStartTime;

      this.stopAutoplay();
      this.track.classList.add("swiping");
    }

    handleMove(x, y, event) {
      if (!this.isDragging) return;

      this.currentX = x;
      this.currentY = y;
      const deltaX = x - this.startX;
      const deltaY = y - this.startY;

      // Only set hasMoved once, after a small threshold to ignore accidental jitters.
      if (!this.hasMoved && (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5)) {
        this.hasMoved = true;
        // Decide if this is a vertical scroll.
        this.isVerticalScroll = Math.abs(deltaY) > Math.abs(deltaX);
      }

      if (this.isVerticalScroll) {
        // If it's a vertical scroll, let the browser handle it and stop our logic.
        this.handleCancel();
        return;
      }

      // If we've determined it's a horizontal drag, prevent default browser actions like text selection or page scrolling.
      if (this.hasMoved) {
        event.preventDefault();
      }

      this.dragOffset = deltaX;

      const now = Date.now();
      this.velocityTracker.push({ time: now, x: deltaX });
      this.velocityTracker = this.velocityTracker.filter(
        (point) => now - point.time <= 100,
      );

      let resistance = 1;
      if (!this.loop) {
        const atStart = this.currentIndex === 0 && deltaX > 0;
        const atEnd =
          this.currentIndex === this.slides.length - 1 && deltaX < 0;
        if (atStart || atEnd) {
          resistance = 0.3;
        }
      }

      const finalOffset = this.dragOffset * resistance;
      const translateX = this.initialTransform + finalOffset;
      this.track.style.transform = `translateX(${translateX}px)`;
    }

    handleEnd(x, y) {
      if (!this.isDragging) return;

      this.isDragging = false;
      this.track.classList.remove("swiping");

      const deltaX = x - this.startX;
      const dragDuration = Date.now() - this.dragStartTime;

      // If it was a vertical scroll, just reset and resume.
      if (this.isVerticalScroll) {
        this.updateSlidePosition(false);
        this.resumeAutoplayIfNeeded();
        return;
      }

      // If the user didn't move enough, it was a click, so do nothing.
      // The click event will fire normally because `hasMoved` is false.
      if (!this.hasMoved) {
        this.resumeAutoplayIfNeeded();
        return;
      }

      let velocity = 0;
      if (this.velocityTracker.length >= 2) {
        const recent = this.velocityTracker[this.velocityTracker.length - 1];
        const older = this.velocityTracker[0];
        const timeDiff = recent.time - older.time;
        if (timeDiff > 0) {
          velocity = (recent.x - older.x) / timeDiff;
        }
      }

      const distanceThreshold = 50;
      const velocityThreshold = 0.5;
      const isQuickSwipe = dragDuration < 300 && Math.abs(deltaX) > 20;

      if (
        Math.abs(deltaX) > distanceThreshold ||
        Math.abs(velocity) > velocityThreshold ||
        isQuickSwipe
      ) {
        if (deltaX > 0) {
          this.goToPrevious();
        } else {
          this.goToNext();
        }
      } else {
        this.updateSlidePosition(true);
      }

      this.resumeAutoplayIfNeeded();

      // Reset hasMoved for the next interaction
      setTimeout(() => {
        this.hasMoved = false;
      }, 0);
    }

    handleCancel() {
      if (!this.isDragging) return;

      this.isDragging = false;
      this.track.classList.remove("swiping");
      this.updateSlidePosition(true);
      this.resumeAutoplayIfNeeded();
    }

    resumeAutoplayIfNeeded() {
      if (this.autoplayResumeTimeout) {
        clearTimeout(this.autoplayResumeTimeout);
      }
      if (this.autoplay) {
        this.autoplayResumeTimeout = setTimeout(() => {
          this.startAutoplay();
          this.autoplayResumeTimeout = null;
        }, 500);
      }
    }

    // ... (The rest of your methods: goToSlide, goToNext, etc. remain the same)

    goToSlide(visualIndex) {
      if (visualIndex < 0 || visualIndex >= this.itemsLength) return;
      if (this.isTransitioning || this.isDragging) return;

      this.visualIndex = visualIndex;

      if (this.loop && this.itemsLength > 1) {
        this.currentIndex = this.itemsLength + visualIndex;
      } else {
        this.currentIndex = visualIndex;
      }

      this.updateSlidePosition(true);
      this.updateDots();
    }

    goToNext() {
      if (this.isTransitioning || this.isDragging) return;

      if (this.loop && this.itemsLength > 1) {
        this.currentIndex++;
        this.visualIndex = (this.visualIndex + 1) % this.itemsLength;
      } else if (this.currentIndex < this.slides.length - 1) {
        this.currentIndex++;
        this.visualIndex++;
      } else {
        return;
      }

      this.updateSlidePosition(true);
      this.updateDots();
    }

    goToPrevious() {
      if (this.isTransitioning || this.isDragging) return;

      if (this.loop && this.itemsLength > 1) {
        this.currentIndex--;
        this.visualIndex =
          this.visualIndex === 0 ? this.itemsLength - 1 : this.visualIndex - 1;
      } else if (this.currentIndex > 0) {
        this.currentIndex--;
        this.visualIndex--;
      } else {
        return;
      }

      this.updateSlidePosition(true);
      this.updateDots();
    }

    updateSlidePosition(withTransition = true) {
      const translateX = -this.currentIndex * (this.slideWidth + this.slideGap);

      if (withTransition) {
        this.track.classList.remove("no-transition", "swiping");
        this.isTransitioning = true;
      } else {
        this.track.classList.add("no-transition");
        this.track.classList.remove("swiping");
        this.isTransitioning = false;
      }

      this.track.style.transform = `translateX(${translateX}px)`;

      if (!withTransition) {
        setTimeout(() => this.handleTransitionEnd(), 0);
      }
    }

    handleTransitionEnd() {
      this.isTransitioning = false;

      if (!this.loop || this.itemsLength <= 1) return;

      // Recalculate the visual index based on the current slide index.
      // This ensures they are always in sync.
      this.visualIndex = this.currentIndex % this.itemsLength;

      // Check if we've landed on a cloned slide at either end
      const needsRepositioning =
        this.currentIndex >= this.itemsLength * 2 ||
        this.currentIndex < this.itemsLength;

      if (needsRepositioning) {
        // Jump back to the equivalent slide in the middle set without an animation
        this.currentIndex = this.itemsLength + this.visualIndex;
        this.updateSlidePosition(false);
      }

      // **Crucially, update the dots AFTER any repositioning.**
      // This guarantees the UI always reflects the final state.
      this.updateDots();
    }

    updateDots() {
      this.dots.forEach((dot, index) => {
        dot.classList.toggle("active", index === this.visualIndex);
      });
    }

    startAutoplay() {
      if (!this.autoplay || this.itemsLength <= 1 || this.isDragging) return;

      this.stopAutoplay();
      this.autoplayTimer = setInterval(() => {
        if (!this.isDragging && !this.isTransitioning) {
          this.goToNext();
        }
      }, this.autoplayInterval);
    }

    stopAutoplay() {
      if (this.autoplayTimer) {
        clearInterval(this.autoplayTimer);
        this.autoplayTimer = null;
      }

      if (this.autoplayResumeTimeout) {
        clearTimeout(this.autoplayResumeTimeout);
        this.autoplayResumeTimeout = null;
      }
    }

    destroy() {
      this.stopAutoplay();
      if (this.navigationDebounce) {
        clearTimeout(this.navigationDebounce);
      }
      if (this.autoplayResumeTimeout) {
        clearTimeout(this.autoplayResumeTimeout);
      }
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    const container = document.querySelector(
      `[data-carousel-id="${carouselId}"]`,
    );
    if (container) {
      new Carousel(container, {
        autoplay,
        autoplayInterval,
        loop,
        renderCustomContent,
        itemsLength,
      });
    }
  });
</script>
